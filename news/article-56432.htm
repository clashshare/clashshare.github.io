<!doctype html>
<html xml:lang="zh-CN" lang="zh-CN">

<head>
        <link rel="canonical" href="https://clashshare.github.io/news/article-56432.htm" />
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Redis：内存淘汰机制</title>
        <meta name="description" content="&nbsp;参考资料： 《Redis的LRU缓存淘汰算法实现》 《一文读懂Redis内存淘汰策略》 《Redis 的过期策略和内存淘汰机制有什么区别》 《Redis内存淘汰策略》 写在开头：本文为学习" />
        <link rel="icon" href="/assets/website/img/clashshare/favicon.ico" type="image/x-icon"/>

    <meta name="author" content="ClashShare节点分享站">
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://clashshare.github.io/news/article-56432.htm" />
    <meta property="og:site_name" content="ClashShare节点分享站" />
    <meta property="og:title" content="Redis：内存淘汰机制" />
    <meta property="og:image" content="https://clashshare.github.io/uploads/20240525/b0155c4bb786cec70c56c4607f7229ee.webp" />
        <meta property="og:release_date" content="2025-02-14T10:02:24" />
    <meta property="og:updated_time" content="2025-02-14T10:02:24" />
        <meta property="og:description" content="&nbsp;参考资料： 《Redis的LRU缓存淘汰算法实现》 《一文读懂Redis内存淘汰策略》 《Redis 的过期策略和内存淘汰机制有什么区别》 《Redis内存淘汰策略》 写在开头：本文为学习" />
        
    <link href="//fonts.googleapis.com/css2?family=Nunito:ital,wght@0,300;0,400;0,600;0,700;0,800;1,300&display=swap" rel="stylesheet">
    <!-- Template CSS -->
    <link rel="stylesheet" href="/assets/website/css/clashshare/style-starter.css">

    <meta name="applicable-device" content="pc,mobile" />
    <meta name="renderer" content="webkit" />
    <meta name="force-rendering" content="webkit" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta name="robots" content="max-image-preview:large" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Redis：内存淘汰机制">
    <meta name="format-detection" content="telephone=no">

    <link rel="dns-prefetch" href="https:/www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googleadservices.com">
    <link rel="dns-prefetch" href="https://www.google-analytics.com">
    <link rel="dns-prefetch" href="https://pagead2.googlesyndication.com">
    <link rel="dns-prefetch" href="https://cm.g.doubleclick.net">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JXCB90C85R"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-JXCB90C85R');
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body data-page="detail">
        <!--/header-w3l-->
    <div class="header-w3l">
        <!-- header -->
        <header id="site-header" class="fixed-top">
            <div class="container">
                <nav class="navbar navbar-expand-lg stroke">
                                        <a class="navbar-brand" href="/">
                        Clash Share                    </a>
                                        <!-- if logo is image enable this   
            <a class="navbar-brand" href="#index.html">
                <img src="image-path" alt="Your logo" title="Your logo" style="height:35px;" />
            </a> -->
                    <button class="navbar-toggler  collapsed bg-gradient" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo02" aria-controls="navbarTogglerDemo02" aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon fa icon-expand fa-bars"></span>
                        <span class="navbar-toggler-icon fa icon-close fa-times"></span>
                        </span>
                    </button>
                    <div class="collapse navbar-collapse" id="navbarTogglerDemo02">
                        <ul class="navbar-nav ml-lg-auto">
                                                        <li class="nav-item">
                                <a class="nav-link" href="/">首页</a>
                            </li>
                                                        <li class="nav-item">
                                <a class="nav-link" href="/free-nodes/">免费节点</a>
                            </li>
                                                        <li class="nav-item">
                                <a class="nav-link" href="/paid-subscribe/">推荐机场</a>
                            </li>
                                                        <li class="nav-item">
                                <a class="nav-link" href="/client.htm">客户端</a>
                            </li>
                                                        <li class="nav-item">
                                <a class="nav-link" href="/news/">新闻资讯</a>
                            </li>
                                                    </ul>
                    </div>
                    <!-- toggle switch for light and dark theme -->
                    <div class="mobile-position">
                        <nav class="navigation">
                            <div class="theme-switch-wrapper">
                                <label class="theme-switch" for="checkbox">
                                    <input type="checkbox" id="checkbox">
                                    <div class="mode-container">
                                        <i class="gg-sun"></i>
                                        <i class="gg-moon"></i>
                                    </div>
                                </label>
                            </div>
                        </nav>
                    </div>
                    <!-- //toggle switch for light and dark theme -->
                </nav>
            </div>
        </header>
        <!-- //header -->
    </div>
    <!--//header-w3l-->
    <!--/w3l-inner-page-breadcrumb-->
    <section class="w3l-inner-page-breadcrumb">
        <div class="breadcrumb-bg py-5">
            <div class="container pt-lg-5 pt-md-3 p-lg-4 pb-md-3 my-lg-3">
                <h2 class="title pt-5">Redis：内存淘汰机制</h2>
                <ul class="breadcrumbs-custom-path mt-3 text-center">
                    <li><a href="/">首页</a></li>
                    <li><a href="/news/">
                        <span class="fa fa-arrow-right mx-2" aria-hidden="true"></span> 新闻资讯</a>
                    </li>
                    <li class="active"><span class="fa fa-arrow-right mx-2" aria-hidden="true"></span> 正文</li>
                </ul>
            </div>
        </div>
    </section>
    <!-- /w3l-content-2-->
    <div class="w3l-content-2 py-5">
        <div class="container">
            <div class="row">
                <div class="col-md-9">
                                    <input type="hidden" id="share-website-info" data-name="" data-url="">
                  				  				  				<div id="content_views" class="htmledit_views"> <p>&nbsp;参考资料：</p> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://javaedge.blog.csdn.net/article/details/122160998"  title="《Redis的LRU缓存淘汰算法实现》" rel="nofollow">《Redis的LRU缓存淘汰算法实现》</a></p> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://baijiahao.baidu.com/s?id=1729630215002937706&amp;wfr=spider&amp;for=pc"  title="《一文读懂Redis内存淘汰策略》" rel="nofollow">《一文读懂Redis内存淘汰策略》</a></p> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=http://t.zoukankan.com/liaowenhui-p-15037902.html"  title="《Redis 的过期策略和内存淘汰机制有什么区别》" rel="nofollow">《Redis 的过期策略和内存淘汰机制有什么区别》</a></p> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://blog.csdn.net/qq_37325859/article/details/125331084"  title="《Redis内存淘汰策略》" rel="nofollow">《Redis内存淘汰策略》</a></p> <p>写在开头：本文为学习后的总结，可能有不到位的地方，错误的地方，欢迎各位指正。</p> <p id="main-toc"><strong>目录</strong></p> <p id="%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" rel="nofollow">一、内存管理</a></p> <p id="%E4%BA%8C%E3%80%81%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5" rel="nofollow">二、过期策略</a></p> <p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4" rel="nofollow">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、定期删除</a></p> <p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4" rel="nofollow">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、惰性删除</a></p> <p id="%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0" rel="nofollow">三、内存淘汰</a></p> <p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201%E3%80%81LRU-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201%E3%80%81LRU" rel="nofollow">&nbsp; &nbsp; &nbsp; &nbsp; 1、LRU</a></p> <p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81LFU-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81LFU" rel="nofollow">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、LFU</a></p> <p id="%E5%9B%9B%E3%80%81%E8%BF%91%E4%BC%BCLRU-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E8%BF%91%E4%BC%BCLRU" rel="nofollow">四、近似LRU</a></p> <p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201%E3%80%81%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201%E3%80%81%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B" rel="nofollow">&nbsp; &nbsp; &nbsp; &nbsp; 1、内容简介</a></p> <p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7" rel="nofollow">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、基础属性</a></p> <p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89redisDb%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89redisDb%C2%A0" rel="nofollow">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）redisDb</a></p> <p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%882%EF%BC%89evictionPoolEntry%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%882%EF%BC%89evictionPoolEntry%C2%A0" rel="nofollow">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）evictionPoolEntry</a></p> <p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203%E3%80%81%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203%E3%80%81%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3" rel="nofollow">&nbsp; &nbsp; &nbsp; &nbsp; 3、源码详解</a></p> <p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B" rel="nofollow">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）整体流程</a></p> <p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%882%EF%BC%89%E6%8A%BD%E5%8F%96%E4%B8%8E%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%882%EF%BC%89%E6%8A%BD%E5%8F%96%E4%B8%8E%E5%88%A0%E9%99%A4" rel="nofollow">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）抽取与删除</a></p> <p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%883%EF%BC%89%E6%B7%98%E6%B1%B0%E6%B1%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%883%EF%BC%89%E6%B7%98%E6%B1%B0%E6%B1%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85" rel="nofollow">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）淘汰池的数据填充</a></p> <p id="%E8%A1%A5%E5%85%85-toc" style="margin-left:0px;"><a href="#%E8%A1%A5%E5%85%85" rel="nofollow">补充</a></p> <p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E7%9A%84%E9%80%89%E6%8B%A9-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E7%9A%84%E9%80%89%E6%8B%A9" rel="nofollow">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、淘汰策略的选择</a></p> <p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE" rel="nofollow">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、使用建议</a></p> <p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03%E3%80%81%E4%BF%AE%E6%94%B9%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03%E3%80%81%E4%BF%AE%E6%94%B9%E6%96%B9%E5%BC%8F" rel="nofollow">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、修改方式</a></p> <hr id="hr-toc"/> </h1> <p>&nbsp; &nbsp; &nbsp; &nbsp; Redis通过将热点数据存储到内存中实现了高效的数据读取，但是内存如果使用不当也是会造成一些问题的。</p> <ul> <li><span style="color:#1c7331;"><strong>Redis中有很多无效的缓存，这些缓存数据会降低数据IO的性能</strong></span>，因为不同的数据类型时间复杂度算法不同，数据越多可能会造成性能下降</li> <li>随着系统的运行，<span style="color:#1c7331;"><strong>redis的数据越来越多，会导致物理内存不足</strong></span>。通过使用虚拟内存（VM），将很少访问的数据交换到磁盘上，腾出内存空间的方法来解决物理内存不足的情况。虽然能够解决物理内存不足导致的问题，但是由于这部分数据是存储在磁盘上，如果在高并发场景中，频繁访问虚拟内存空间会严重降低系统性能。</li> </ul> <p>&nbsp; &nbsp; &nbsp; &nbsp; 因此，Redis为了更好的管理内存，提供了一些管理方案，包括过期策略与内存淘汰。</p> </h1> <p>&nbsp; &nbsp; &nbsp; &nbsp; 过期策略是指对每个存储到redis中的key设置过期时间。Redis提供了&nbsp;EXPIRE 与&nbsp;EXPIREAT 来为 key 设置过期时间。</p> <pre><code class="language-bash">redis&gt; SET mykey "Hello" "OK" redis&gt; EXPIRE mykey 10 (integer) 1 redis&gt; TTL mykey (integer) 10 redis&gt; SET mykey "Hello World" "OK" redis&gt; TTL mykey (integer) -1 redis&gt;</code></pre> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当到达过期时间后，就需要将这个key删除掉（准确来说，是该key会变为不可使用，而后再利用专门的过期策略对其进行删除）。Redis中提供了两种过期删除策略：惰性删除和定期删除。</p> <h2 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、定期删除</h2> <p>&nbsp; &nbsp; &nbsp; &nbsp; 定期删除类似一个守护线程，每间隔一段时间就执行一次（默认100ms一次，可以通过修改配置文件redis.conf 的 hz 选项来调整这个次数），将过期的Key进行删除，具体过程如下：</p> <ul> <li><span style="color:#1c7331;"><strong>从过期字典中随机选出20个key；</strong></span></li> <li><span style="color:#1c7331;"><strong>删除这20个key中已经过期的key；</strong></span></li> <li><span style="color:#1c7331;"><strong>如果过期的key的比例超过了1/4，那就重复从步骤1开始执行；</strong></span></li> </ul> <p><span style="color:#e6b223;"><strong>之所以不一次性将所有过期的key都删除，是从性能角度做出的考量，当过期key特别多时，每次扫描全部的过期key，都会给CPU带来较大负担。既然无法一下子全部删除，那么我就进行多次（指每100ms执行一次，提高删除的频次）、部分的删除（只每次只抽取部分进行删除），以此来达到效果</strong>。</span></p> <p>&nbsp; &nbsp; &nbsp; &nbsp; 当然，这样随机的抽取过期key进行删除明显会遗漏很多过期key，这就要用到惰性删除。</p> <h2 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、惰性删除</h2> <p>&nbsp; &nbsp; &nbsp; &nbsp; 惰性删除即当查询某个Key时，判断该key是否已过期，如果已过期则从缓存中删除，同时返回空。</p> <p>&nbsp; &nbsp; &nbsp; &nbsp; 这一块的思路其实挺类似mysql的内存数据写回策略Merge buffer，只不过一个是写回磁盘一个是从内存删除。有兴趣的朋友可以看看我之前的文章<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://blog.csdn.net/wzngzaixiaomantou/article/details/121064577"  title="《mysql中的Innodb_buffer_pool》" rel="nofollow">《mysql中的Innodb_buffer_pool》</a></p> <p><img fetchpriority="high" decoding="async" alt="" height="420" src="http://img.555519.xyz/uploads3/20220829/b2cab8fa184d5bd5f7646a58673e99c8.jpg"></p> <p><span style="color:#e6b223;"><strong> &nbsp; &nbsp; 再回头看看过期策略，无论是定期删除还是惰性删除，都是一种不完全精确的删除策略，始终还是会存在已经过期的key无法被删除的场景。而且这两种过期策略都是只针对设置了过期时间的key，不适用于没有设置过期时间的key的淘汰，所以，Redis还提供了内存淘汰策略，用来筛选淘汰指定的key。</strong></span></p> </h1> <p>&nbsp; &nbsp; &nbsp; &nbsp; 在配置文件redis.conf 中，可以通过参数 maxmemory &lt;bytes&gt; 来设定最大内存，当数据内存达到 maxmemory 时，便会触发redis的内存淘汰策略（我们一般会将该参数设置为物理内存的四分之三）。</p> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;当 Redis 的内存超过最大允许的内存之后，Redis 会触发内存淘汰策略。（过期策略是指正常情况下清除过期键，内存淘汰是指内存超过最大值时的保护策略）。内存淘汰策略可以通过maxmemory-policy进行配置，目前Redis提供了以下几种（2个LFU的策略是4.0后出现的）：</p> <ul> <li><strong><span style="color:#1c7331;">volatile-lru，针对设置了过期时间的key，使用lru算法进行淘汰。</span></strong></li> <li><strong><span style="color:#1c7331;">allkeys-lru，针对所有key使用lru算法进行淘汰。</span></strong></li> <li><strong><span style="color:#1c7331;">volatile-lfu，针对设置了过期时间的key，使用lfu算法进行淘汰。</span></strong></li> <li><strong><span style="color:#1c7331;">allkeys-lfu，针对所有key使用lfu算法进行淘汰。</span></strong></li> <li><strong><span style="color:#1c7331;">volatile-random，从所有设置了过期时间的key中使用随机淘汰的方式进行淘汰。</span></strong></li> <li><strong><span style="color:#1c7331;">allkeys-random，针对所有的key使用随机淘汰机制进行淘汰。</span></strong></li> <li><strong><span style="color:#1c7331;">volatile-ttl，针对设置了过期时间的key，越早过期的越先被淘汰。</span></strong></li> <li><strong><span style="color:#1c7331;">noeviction，不会淘汰任何数据，当使用的内存空间超过 maxmemory 值时，再有写请求来时返回错误。</span></strong></li> </ul> <p>&nbsp; &nbsp; &nbsp; &nbsp; 除了比较特殊的noeviction与volatile-ttl，其余6种策略都有一定的关联性。<strong><span style="color:#e6b223;">我们可以通过前缀将它们分为2类，volatile-与allkeys-，这两类策略的区别在于二者选择要清除的键时的字典不同，volatile-前缀的策略代表从设置了过期时间的key中选择键进行清除；allkeys-开头的策略代表从所有key中选择键进行清除。这里面值得介绍的就是lru与lfu了，下面会对这两种方式进行介绍</span>。</strong></p> <h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201%E3%80%81LRU">&nbsp; &nbsp; &nbsp; &nbsp; 1、LRU</h2> <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;LRU是Least Recently Used的缩写，也就是表示最近很少使用，也可以理解成最久没有使用。也就是说当内存不够的时候，每次添加一条数据，都需要抛弃一条最久时间没有使用的旧数据。（一个key上一次的访问时间存储redisObject中的lru字段中，该点前文中有介绍<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://blog.csdn.net/wzngzaixiaomantou/article/details/125288026"  title="《Redis：数据对象与底层实现》" rel="nofollow">《Redis：数据对象与底层实现》</a>）</p> <p><img decoding="async" alt="" src="http://img.555519.xyz/uploads3/20220829/7985a5672471d450a682fe78e4b53dd4.jpg"></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LRU 是基于链表结构实现的，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要进行内存淘汰时，只需要删除链表尾部的元素即可。LRU的具体实现可以看看LeetCode上的经典题目<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://leetcode.cn/problems/lru-cache/"  title="146. LRU 缓存" rel="nofollow">146. LRU 缓存</a></p> <p class="img-center"><img decoding="async" alt="" src="http://img.555519.xyz/uploads3/20220829/ed41e3fe2cda520389284dc1eb4f9c00.jpg"></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是Redis并没有使用标准的LRU实现方法作为LRU淘汰策略的实现方式，这是因为：</p> <ul> <li><span style="color:#1c7331;"><strong>要实现LRU，需要将所有数据维护一个链表，这就需额外内存空间来保存链表</strong></span></li> <li><span style="color:#1c7331;"><strong>每当有新数据插入或现有数据被再次访问，都要调整链表中节点的位置，尤其是频繁的操作将会造成巨大的开销（不要忘了Redis就是为了存储热点数据而出现的，这必然导致数据出现高频的访问）</strong></span></li> </ul> <p>&nbsp; &nbsp; &nbsp; &nbsp; 为了解决这一问题，Redis使用了近似的LRU策略进行了优化，平衡了时间与空间的效率。具体的实现细节我们会在下文中介绍。</p> <p>&nbsp; &nbsp; &nbsp; &nbsp; LRU虽然看起来实现了按照数据的热度对内存中的key进行管理，但是在某些情况下却仍然存在一些问题，假设有一个数据很久没有被访问了，偶然间被访问了一次，lur字段值被更新，那么在lru的策略下，这个近期刚被访问过的节点会被保留，但显然这个key并不是我们想要保留的热点数据。为了解决这一问题，便有了LFU。</p> <h2 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81LFU">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、LFU</h2> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LFU（Least Frequently Used），表示最近最少使用，它和key的使用次数有关，其思想是：根据key最近被访问的频率进行淘汰，比较少访问的key优先淘汰，反之则保留。</p> <p><span style="color:#be191c;"><strong>&nbsp;相比LRU算法,LFU增加了访问频率的这样一个维度来统计数据的热点情况，LFU主要使用了两个双向链表去形成一个二维的双向链表，一个用来保存访问频率，另一个用来访问频率相同的所有元素，其内部按照访问时间排序。</strong></span></p> <ul> <li><strong><span style="color:#1c7331;">当添加元素的时候访问频次默认为1，于是找到相同频次的节点，然后添加到相同频率节点对应的双向链表的头部，</span></strong></li> <li><span style="color:#1c7331;"><strong>当元素被访问的时候就会增加对应key的访问频率，并且把访问的节点移动到下一个频次的节点。</strong></span></li> </ul> <p><span style="color:#e6b223;"><strong>&nbsp;LFU算法通过使用频率和上次访问时间来标记数据的这样一个热度，如果某个数据有读和写那么就增加访问的频率，如果一段时间内这个数据没有读写,那么就减少访问频率。所以通过LFU算法改进之后，就可以真正达到非热点数据的淘汰，当然LFU也有缺点，相比LRU算法，LFU增加了访问频次的一个维护，以及实现的复杂度比LRU更高。</strong></span></p> <p><img decoding="async" alt="" height="322" src="http://img.555519.xyz/uploads3/20220829/73a3cb4fd353be351dec91befbb50e85.jpg"></p> </h1> <h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201%E3%80%81%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B">&nbsp; &nbsp; &nbsp; &nbsp; 1、内容简介</h2> <p><span style="color:#be191c;"><strong>&nbsp; &nbsp; &nbsp; &nbsp; 近似LRU在执行时，会随机抽取N个key，找出其中最久未被访问的key（通过redisObject中的lru字段计算得出），然后删除这个key。然后再判当前内存是超过限制，如仍超标则继续上述过程。</strong></span></p> <p><span style="color:#be191c;"><strong></strong></span><span style="color:#0d0016;"><strong> &nbsp; 随机抽取的个数N可以通过</strong>redis.conf的<strong>配置进行修改，默认为5。之所以设置为5，是Redis官方压测后得出的结论</strong></span><span style="color:#be191c;"><strong>（<span style="color:#be191c;"><strong><a class="link-info" href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://redis.io/docs/manual/eviction/"  title="传送门" rel="nofollow">传送门</a></strong></span>）。</strong></span></p> <pre><code class="language-bash"># The default of 5 produces good enough results. 10 Approximates very closely # true LRU but costs more CPU. 3 is faster but not very accurate. # # maxmemory-samples 5</code></pre> <p><span style="color:#be191c;"><strong></strong></span><span style="color:#e6b223;"><strong>下图就是Redis官方的简述，大概意思为，当抽取参数为5时，已经很接近标准的LRU算法的效果了，虽然抽取参数为10时可以更接近，但是这会导致CPU的负担加重，折中考虑后选择了5。</strong></span></p> <p><img decoding="async" alt="" height="793" src="http://img.555519.xyz/uploads3/20220829/cb7dd3a2238bd69973a59d7cc7077e7c.jpg"></p> <p><img loading="lazy" decoding="async" alt="" height="459" src="http://img.555519.xyz/uploads3/20220829/4b06a4a815ea90eded11ddf2907031f2.jpg"></p> <p><span style="color:#0d0016;"></span><span style="color:#511b78;"><strong>另外，Redis3.0在2.8的基础上增加了一个淘汰池。在原来的策略中，每次抽取的key在删除最久未被访问的元素后即全部释放，而3.0增加了一个淘汰池（实现方式为数组），每次抽取完，都会将所有的key放入淘汰池中，然后删除数组最后一个非空元素（数组内按空闲时间由小到大排序，最后一个非空元素就是我们要删除的最久未被访问的元素），淘汰池种剩下的元素再参与下一次删除过程。</strong></span></p> <h2 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、基础属性</h2> <p>&nbsp; &nbsp; &nbsp; &nbsp; 在介绍近似LRU方法的源码前，我们先介绍2个下文要用到的基础属性</p> <h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89redisDb%C2%A0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）redisDb</h3> <p>&nbsp; &nbsp; &nbsp; &nbsp; redis默认提供16个数据库，<strong><span style="color:#1c7331;">其中使用dict与expires两个字典结构分别报错该数据库内所有的key以及设置了过期时间的key</span></strong>。当我们的淘汰策略是<span style="color:#0d0016;">volatile-lru时，则时从expires中取样。</span></p> <pre><code class="language-cpp">// Redis 数据库。 有多个数据库由从 0（默认数据库）到最大配置数据库的整数标识。 // 数据库编号是结构中的“id”字段。 typedef struct redisDb {     // 所有键值对     dict *dict;                    // 设置超时时间的key集合     dict *expires;                   // 数据库编号     int id;                          // 其他属性     ... } redisDb;</code></pre> <h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%882%EF%BC%89evictionPoolEntry%C2%A0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）evictionPoolEntry</h3> <p>&nbsp; &nbsp; &nbsp; &nbsp; 上文中提到了3.0时启用了淘汰池的策略，这个淘汰池默认大小为16，里面存放的元素为evictionPoolEntry类型。<span style="color:#be191c;"><strong>该类型中使用idle来记录每个key的空闲时间，当压入淘汰池中时就是通过比较该节点判断出所插入的位置</strong></span>。</p> <pre><code class="language-cpp">// 淘汰池大小 #define EVPOOL_SIZE 16 // 淘汰池缓存的最大sds大小 #define EVPOOL_CACHED_SDS_SIZE 255  struct evictionPoolEntry {     // 对象空闲时间，根据lru时间计算得到     unsigned long long idle;         sds key;                         // 用来存储一个sds对象留待复用，注意我们要复用的是sds的内存空间     // 只需关注cached的长度（决定是否可以复用），无需关注他的内容     sds cached;           // 数据库id                int dbid;                    };</code></pre> <h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203%E3%80%81%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3"><span style="color:#0d0016;">&nbsp; &nbsp; &nbsp; &nbsp; 3、源码详解</span></h2> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 整个近似LRU的流程如下（图片来源<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://javaedge.blog.csdn.net/article/details/122160998"  title="《Redis的LRU缓存淘汰算法实现》" rel="nofollow">《Redis的LRU缓存淘汰算法实现》</a>）：</p> <p><img decoding="async" alt="" src="http://img.555519.xyz/uploads3/20220829/bfd943c9cc21547a9b91d6130b81cc6b.jpg"></p> <h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span style="color:#0d0016;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）整体流程</span></h3> <p>&nbsp; &nbsp; &nbsp; &nbsp; redis使用freeMemoryIfNeeded释放内存，该方法内部只要执行以下两个逻辑：</p> <ul> <li><span style="color:#1c7331;"><strong>判断是否需要释放内存</strong></span></li> <li><span style="color:#1c7331;"><strong>循环释放内存直到满足要求</strong></span></li> </ul> <pre><code class="language-cpp">int freeMemoryIfNeeded(void) {     // 三个变量分别为已使用内存、需要释放的内存、已释放内存     size_t mem_reported, mem_tofree, mem_freed;          // 检查内存状态，有没有超出限制，如果有，会计算需要释放的内存和已使用内存     // 这个方法不但会计算内存，还会赋值 mem_reported mem_freed     if (getMaxmemoryState(&amp;mem_reported,NULL,&amp;mem_tofree,NULL) == C_OK)         return C_OK;     // 初始化已释放内存的字节数为 0     mem_freed = 0;          // 不进行内存淘汰     if (server.maxmemory_policy == MAXMEMORY_NO_EVICTION)         goto cant_free;               // 根据 maxmemory 策略遍历字典，释放内存并记录被释放内存的字节数     while (mem_freed &lt; mem_tofree) {         // 最佳淘汰key         sds bestkey = NULL;         // LRU策略或者LFU策略或者VOLATILE_TTL策略         if (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) ||             server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL)         {             // 不同的策略找bestKey         }         /* volatile-random and allkeys-random policy */         else if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||                  server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)         {             // 不同的策略找bestKey         }         // 最后选定的要删除的key         if (bestkey) {             // 在这里删除key         }     } }</code></pre> <h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%882%EF%BC%89%E6%8A%BD%E5%8F%96%E4%B8%8E%E5%88%A0%E9%99%A4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）抽取与删除</h3> <p>&nbsp; &nbsp; &nbsp; &nbsp; 当策略为LUR时，会进行2个步骤</p> <pre><code class="language-cpp">// LRU策略或者LFU策略或者VOLATILE_TTL策略 if (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) ||     server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL) {     // 抽取key填充淘汰池     // 从淘汰池中删除末端的key }</code></pre> <ul> <li><span style="color:#1c7331;"><strong>抽取key填充淘汰池</strong></span></li> </ul> <p><span style="color:#be191c;"><strong>&nbsp; &nbsp; &nbsp; &nbsp; 首先创建淘汰池，即一个大小为16的数组，然后遍历所有的数据库，进行取样抽取要删除的key，并调用evictionPoolPopulate将被抽取的key填充进入淘汰池。</strong></span></p> <pre><code class="language-cpp">   // 淘汰池     struct evictionPoolEntry *pool = EvictionPoolLRU;      while(bestkey == NULL) {         unsigned long total_keys = 0, keys;          // 从每个数据库抽样key填充淘汰池         for (i = 0; i &lt; server.dbnum; i++) {             db = server.db+i;             // db-&gt;dict: 数据库所有key集合             // db-&gt;expires: 数据中设置过期时间的key集合             // 判断淘汰策略是否是针对所有键的             dict = (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ?                     db-&gt;dict : db-&gt;expires;             // 计算字典元素数量，不为0才可以挑选key             if ((keys = dictSize(dict)) != 0) {                 // 填充淘汰池，四个参数分别为 dbid，候选集合，主字典集合，淘汰池                 // 填充完的淘汰池内部是有序的，按空闲时间升序                 evictionPoolPopulate(i, dict, db-&gt;dict, pool);                 // 已遍历检测过的key数量                 total_keys += keys;             }         }         // 如果 total_keys = 0，没有要淘汰的key（redis没有key或者没有设置过期时间的key），break         if (!total_keys) break; /* No keys to evict. */</code></pre> <ul> <li><span style="color:#1c7331;"><strong>从淘汰池中删除末端的key</strong></span></li> </ul> <p><span style="color:#be191c;"><strong>&nbsp; &nbsp; &nbsp; &nbsp;在淘汰池中，所有节点按空闲时间由小到大的顺序排序（key插入其中的方法是从索引0位开始遍历找到第一个可插入位置），所以当要从其中删除最久未使用的元素时，逆序遍历数组找到的第一个非空元素即是我们的目标，找到这个元素后执行相应删除逻辑即可。</strong></span></p> <pre><code class="language-cpp">        // 遍历淘汰池，从淘汰池末尾（空闲时间最长）开始向前迭代         for (k = EVPOOL_SIZE-1; k &gt;= 0; k--) {             if (pool[k].key == NULL) continue;             // 获取当前key所属的dbid             bestdbid = pool[k].dbid;              if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) {                 // 如果淘汰策略针对所有key，从 redisDb.dict 中取数据，redisDb.dict 指向所有的键值集合                 de = dictFind(server.db[pool[k].dbid].dict,                     pool[k].key);             } else { // 如果淘汰策略不是针对所有key，从 redisDb.expires 中取数据，redisDb.expires 指向已过期键值集合                 de = dictFind(server.db[pool[k].dbid].expires,                     pool[k].key);             }                         if (pool[k].key != pool[k].cached)                 sdsfree(pool[k].key);             // 从池中删除这个key，不管这个key还在不在             pool[k].key = NULL;             pool[k].idle = 0;              // 如果这个节点存在，就跳出这个循环，否则尝试下一个元素。             // 这个节点可能已经不存在了，比如到了过期时间被删除了             if (de) {                 // de是key所在哈希表节点，bestkey是 key 名                 bestkey = dictGetKey(de);                 break;             } else {                 /* Ghost... Iterate again. */             }         }     }</code></pre> <h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%883%EF%BC%89%E6%B7%98%E6%B1%B0%E6%B1%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）淘汰池的数据填充</h3> <p>&nbsp; &nbsp; &nbsp; &nbsp; 在上文中，我们介绍到evictionPoolPopulate方法会将元素插入到淘汰池中，这里我们详细看下插入的方法。</p> <p>&nbsp; &nbsp; &nbsp; &nbsp; 整个过程也分为两部分是，插入位置查找与插入。</p> <pre><code class="language-cpp">void evictionPoolPopulate(int dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool) {     // 插入位置查找     // 复用插入位置的内存进行插入     }</code></pre> <ul> <li><span style="color:#1c7331;"><strong>插入位置查找</strong></span></li> </ul> <p>&nbsp; &nbsp; &nbsp; &nbsp; 这段逻辑首先计算空闲时间，针对不同的策略计算方法也各不相同。然后就是插入淘汰池，这里存在多个判断，分别如下：</p> <p><span style="color:#511b78;"><strong>&nbsp; &nbsp; &nbsp; &nbsp; （1）当前位置元素空闲时间小于key的空闲时间，则继续向后遍历</strong></span></p> <p><span style="color:#511b78;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）key遍历到了某个位置，该位置左侧所有元素空闲时间均小于key，且该位置为空，则直接插入。由于整个查投入过程是从左到右的，所以当前key必然是目前最久未使用的key。</strong></span></p> <p><span style="color:#511b78;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）key遍历到了某个位置，该位置左侧所有元素空闲时间均小于key，但此时该位置已有元素，不过数组最右侧为空，那么我们就将从这个位置到最右侧的所有元素全部右移一位，这样key就可以插入到当前位置了。</strong></span></p> <p><span style="color:#511b78;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（4）key遍历到了某个位置，该位置左侧所有元素空闲时间均小于key，但此时该位置已有元素，同时整个数组都满了，因为我们要保留最久未使用的元素，所以这里我们与上文相反，将0到当前位置的元素全部左移一位，给key腾出插入空间。</strong></span></p> <pre><code class="language-cpp">    // 初始化抽样集合，大小为 server.maxmemory_samples     dictEntry *samples[server.maxmemory_samples];     // 此函数对字典进行采样以从随机位置返回一些键     count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);     for (j = 0; j &lt; count; j++) {         // 空闲时间         unsigned long long idle;         // key         sds key;         // 值对象         robj *o;         // 哈希表节点         dictEntry *de;          de = samples[j];         key = dictGetKey(de);          /* 如果我们采样的字典不是主字典（而是过期的字典），我们需要在键字典中再次查找键以获得值对象。*/         if (server.maxmemory_policy != MAXMEMORY_VOLATILE_TTL) {             if (sampledict != keydict) de = dictFind(keydict, key);             o = dictGetVal(de);         }          /* 根据策略计算空闲时间 */         if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU) {             // 给定一个对象，使用近似的 LRU 算法返回未请求过该对象的最小毫秒数             idle = estimateObjectIdleTime(o);         } else if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) {  			// LFU 策略也是用这个池子             idle = 255-LFUDecrAndReturn(o);         } else if (server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL) {             // 在这种情况下，越早过期越好。             idle = ULLONG_MAX - (long)dictGetVal(de);         } else {             serverPanic("Unknown eviction policy in evictionPoolPopulate()");         }          /* 将元素插入池中*/         k = 0;         // 遍历淘汰池，从左边开始，找到第一个空位置或者第一个空闲时间大于等于待选元素的位置，k是该元素的坐标         while (k &lt; EVPOOL_SIZE &amp;&amp;                pool[k].key &amp;&amp;                pool[k].idle &lt; idle) k++;         if (k == 0 &amp;&amp; pool[EVPOOL_SIZE-1].key != NULL) {             /* 如果元素小于我们拥有的最差元素并且没有空桶，则无法插入。              *               * key == 0 说明上面的while循环一次也没有进入              * 要么第一个元素就是空的，要么所有已有元素的空闲时间都大于等于待插入元素的空闲时间（待插入元素比已有所有元素都优质）              * 又因为数组最后一个key不为空，因为是从左边开始插入的，所以排除了第一个元素是空的              */             continue;         } else if (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key == NULL) {             /* 当前位置无元素，直接插入即可 */         } else {             // 当前key找到了数组中可插入的位置，但该点已有元素时存在2种可能             if (pool[EVPOOL_SIZE-1].key == NULL) {  				// 1.数组未满，最右侧为空，则当前位置向右的所有元素全部 			    // 右移一位，以此来实现元素的插入                 /* 覆盖前保存 SDS */                 sds cached = pool[EVPOOL_SIZE-1].cached;                 // 注意这里不设置 pool[k], 只是给 pool[k] 腾位置                 memmove(pool+k+1,pool+k,                     sizeof(pool[0])*(EVPOOL_SIZE-k-1));                 // 转移 cached (sds对象)                 pool[k].cached = cached;             } else {                 // 2. 数组已满，则将0到当前位置（k）的元素由1到k的元素覆盖 				// 并将key插入到k的位置                 k--;                 sds cached = pool[0].cached;                 if (pool[0].key != pool[0].cached) sdsfree(pool[0].key);                 memmove(pool,pool+1,sizeof(pool[0])*k);                 pool[k].cached = cached;             }         }</code></pre> <p><span style="color:#e6b223;"><strong>&nbsp; &nbsp; &nbsp; &nbsp; 总结一下就是：</strong></span></p> <p><strong><span style="color:#1c7331;">&nbsp; &nbsp; &nbsp; &nbsp; 无论何时，空闲时间小于最小元素的不能插入</span></strong></p> <p><strong><span style="color:#1c7331;">&nbsp; &nbsp; &nbsp; &nbsp; 淘汰池未满时，空闲时间大于最大元素，则插入到右侧第一个空位；空闲时间介于最小与最大之间，则将大于key空闲时间的元素全部右移一位，然后插入key。</span></strong></p> <p><strong><span style="color:#1c7331;">&nbsp; &nbsp; &nbsp; &nbsp; 淘汰池满了后，则将小于key空闲时间的元素全部左移一位（这里会抛弃第0位的元素），然后插入key。</span></strong></p> <ul> <li><span style="color:#1c7331;"><strong>插入key</strong></span></li> </ul> <pre><code class="language-cpp">        /*          * 尝试重用在池条目中分配的缓存 SDS 字符串，因为分配和释放此对象的成本很高          * 注意真正要复用的sds内存空间，避免重新申请内存，而不是他的值          */         int klen = sdslen(key);         // 判断字符串长度来决定是否复用sds         if (klen &gt; EVPOOL_CACHED_SDS_SIZE) {             // 复制一个新的 sds 字符串并赋值             pool[k].key = sdsdup(key);         } else {             /*              * 内存拷贝函数，从数据源拷贝num个字节的数据到目标数组              *               * destination：指向目标数组的指针               * source：指向数据源的指针               * num：要拷贝的字节数              *              */             // 复用sds对象             memcpy(pool[k].cached,key,klen+1);             // 重新设置sds长度             sdssetlen(pool[k].cached,klen);             // 真正设置key             pool[k].key = pool[k].cached;         }         // 设置空闲时间         pool[k].idle = idle;         // 设置key所在db         pool[k].dbid = dbid;     }</code></pre> <p>&nbsp; &nbsp; &nbsp; &nbsp; 至此，近似LRU查找要删除的key的过程就介绍完毕了，后面就是删除的过程了，这里不多作介绍了，有兴趣的可以看看这篇文章，有详细介绍<a class="link-info" href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.debugger.wiki/article/html/1626067080291402"  title="《Redis 内存淘汰策略》" rel="nofollow">《Redis 内存淘汰策略》</a>。</p> </h1> <h2 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E7%9A%84%E9%80%89%E6%8B%A9">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、淘汰策略的选择</h2> <ul> <li><span style="color:#1c7331;"><strong>如果数据呈现幂等分布(即部分数据访问频率较高而其余部分访问频率较低)，建议使用 allkeys-lru。</strong></span></li> <li><span style="color:#1c7331;"><strong>如果数据呈现平等分布(即所有数据访问概率大致相等)，建议使用 allkeys-random。</strong></span></li> <li><span style="color:#1c7331;"><strong>如果需要通过设置不同的ttls来确定数据过期的顺序，建议使用volatile-ttl。</strong></span></li> <li><span style="color:#1c7331;"><strong>如果你想让一些数据长期保存，而一些数据可以消除，建议使用volatile-lru或volatile-random。</strong></span></li> </ul> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于设置expire会消耗额外的内存，如果你打算避免Redis内存浪费在这一项上，可以选择allkeys-lru策略，这样就可以不再设置过期时间，高效利用内存。</p> <h2 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、使用建议</h2> <p>&nbsp; &nbsp; &nbsp; &nbsp; 虽然Redis提供了内存淘汰策略，但我们最好还是精简对Redis的使用，尽量不要淘汰内存数据。下面是一些使用建议：</p> <ul> <li><strong><span style="color:#1c7331;">不要放垃圾数据，及时清理无用数据。</span></strong></li> <li><strong><span style="color:#1c7331;">key尽量都设置过期时间。对具有时效性的key设置过期时间，通过redis自身的过期key清理策略来降低过期key对于内存的占用，同时也能够减少业务的麻烦，不需要定期手动清理了。</span></strong></li> <li><strong><span style="color:#1c7331;">单Key不要过大，这种key造成的网络传输延迟会比较大，需要分配的输出缓冲区也比较大，在定期清理的时候也容易造成比较高的延迟. 最好能通过业务拆分，数据压缩等方式避免这种过大的key的产生。</span></strong></li> <li><strong><span style="color:#1c7331;">不同业务如果公用一个业务的话，最好使用不同的逻辑db分开。这是因为Redis的过期Key清理策略和强制淘汰策略都会遍历各个db。将key分布在不同的db有助于过期Key的及时清理。另外不同业务使用不同db也有助于问题排查和无用数据的及时下线。</span></strong></li> </ul> <h2 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03%E3%80%81%E4%BF%AE%E6%94%B9%E6%96%B9%E5%BC%8F">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、修改方式</h2> <ul> <li>方式一：通过 config set maxmemory-policy 策略 命令设置。它的优点是设置之后立即生效，不需要重启 Redis 服务，缺点是重启 Redis 之后，设置就会失效。</li> <li>&nbsp;方式二：通过修改 Redis 配置文件修改，设置 maxmemory-policy 策略，它的优点是重启 Redis 服务后配置不会丢失，缺点是必须重启 Redis 服务，设置才能生效</li> </ul> </div> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-56431.htm">Python向hdfs写入文件与hadoop命令向hdfs写入文件</a></p>
                                        <p>下一个：<a href="/news/article-56989.htm">国内宠物粮食品牌排行榜（国内十大宠物粮食品牌）</a></p>
                                    </div>
                                </div>
                <div class="col-md-3">
                    <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/free-nodes/2025-1-24-free-subscribe-node.htm" title="1月24日|最高速度18.5M/S，2025最新Clash/Shadowrocket/SSR/V2ray免费节点订阅链接地址">1月24日|最高速度18.5M/S，2025最新Clash/Shadowrocket/SSR/V2ray免费节点订阅链接地址</a></li>
                        <li class="py-2"><a href="/news/article-28971.htm" title="SpringCloud-2.X 学习笔记01 Eureka Server 搭建">SpringCloud-2.X 学习笔记01 Eureka Server 搭建</a></li>
                        <li class="py-2"><a href="/news/article-59245.htm" title="没钱别养布偶（养布偶猫很费钱吗）">没钱别养布偶（养布偶猫很费钱吗）</a></li>
                        <li class="py-2"><a href="/news/article-42024.htm" title="Vue&#8211;》混合文件使用以及ref的引用讲解">Vue&#8211;》混合文件使用以及ref的引用讲解</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-12-22-node-share.htm" title="12月22日|最高速度22.1M/S，2024最新Clash/Shadowrocket/SSR/V2ray免费节点订阅链接地址">12月22日|最高速度22.1M/S，2024最新Clash/Shadowrocket/SSR/V2ray免费节点订阅链接地址</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-2-4-free-clash-subscribe.htm" title="2月4日|最高速度22.5M/S，2025最新V2ray/Clash/SSR/Shadowrocket免费节点订阅链接地址">2月4日|最高速度22.5M/S，2025最新V2ray/Clash/SSR/Shadowrocket免费节点订阅链接地址</a></li>
                        <li class="py-2"><a href="/news/article-25724.htm" title="Java连接MySQL数据——命令行程序">Java连接MySQL数据——命令行程序</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-2-17-free-node-subscribe.htm" title="2月17日|最高速度20.7M/S，2025最新V2ray/Shadowrocket/Clash/SSR免费节点订阅链接地址">2月17日|最高速度20.7M/S，2025最新V2ray/Shadowrocket/Clash/SSR免费节点订阅链接地址</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-1-13-clash-node-daily-updates.htm" title="1月13日|最高速度19.6M/S，2025最新Clash/SSR/Shadowrocket/V2ray免费节点订阅链接地址">1月13日|最高速度19.6M/S，2025最新Clash/SSR/Shadowrocket/V2ray免费节点订阅链接地址</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-2-10-free-ssr-subscribe.htm" title="2月10日|最高速度19.9M/S，2025最新Clash/SSR/V2ray/Shadowrocket免费节点订阅链接地址">2月10日|最高速度19.9M/S，2025最新Clash/SSR/V2ray/Shadowrocket免费节点订阅链接地址</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">6</span> <a href="/date/2025-03/" title="2025-03 归档">2025-03</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">84</span> <a href="/date/2025-02/" title="2025-02 归档">2025-02</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">93</span> <a href="/date/2025-01/" title="2025-01 归档">2025-01</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">87</span> <a href="/date/2024-12/" title="2024-12 归档">2024-12</a></h4>
            </li>
                    </ul>
    </div>
</div>



                </div>
            </div>
        </div>
    </div>
    <!-- //w3l-content-2-->
        <!-- footer -->
    <footer class="w3l-footer-29-main">
        <!-- copyright -->
        <section class="w3l-copyright">
            <div class="container">
                <div class="row bottom-copies">
                    <p class="col-lg-8 copy-footer-29">
                            <p>
                                <a href="/">首页</a> | 
                                <a href="/free-node/">免费节点</a> | 
                                <a href="/news/">新闻资讯</a> |
                                <a href="/about-us.htm">关于我们</a> |
                                <a href="/disclaimer.htm">免责申明</a> |
                                <a href="/privacy.htm">隐私申明</a> |
                                <a href="/sitemap.xml">网站地图</a>
                            </p>
                        ClashShare节点分享站 版权所有 Powered by WordPress
                    </p>
                    <div class="col-lg-4 footer-list-29">
                        <ul class="d-flex text-lg-right">
                            <li class="mx-lg-5 mx-md-4 mx-3"><a href="#">Privacy Policy</a></li>
                            <li><a href="#">Contact Us</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>
        <!-- move top -->
        <button onclick="topFunction()" id="movetop" title="Go to top">
            &#10548;
        </button>
        <script>
        // When the user scrolls down 20px from the top of the document, show the button
        window.onscroll = function() {
            scrollFunction()
        };

        function scrollFunction() {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                document.getElementById("movetop").style.display = "block";
            } else {
                document.getElementById("movetop").style.display = "none";
            }
        }

        // When the user clicks on the button, scroll to the top of the document
        function topFunction() {
            document.body.scrollTop = 0;
            document.documentElement.scrollTop = 0;
        }
        </script>
        <!-- /move top -->
    </footer>
    <!--//footer-->
    <!-- Template JavaScript -->
    <script src="/assets/website/js/frontend/clashshare/jquery-3.5.1.min.js"></script>
    <script src="/assets/website/js/frontend/clashshare/theme-change.js"></script>
    <!-- disable body scroll which navbar is in active -->
    <script>
    $(function() {
        $('.navbar-toggler').click(function() {
            $('body').toggleClass('noscroll');
        })
    });
    </script>
    <!-- disable body scroll which navbar is in active -->
    <!--/MENU-JS-->
    <script>
    $(window).on("scroll", function() {
        var scroll = $(window).scrollTop();

        if (scroll >= 80) {
            $("#site-header").addClass("nav-fixed");
        } else {
            $("#site-header").removeClass("nav-fixed");
        }
    });

    //Main navigation Active Class Add Remove
    $(".navbar-toggler").on("click", function() {
        $("header").toggleClass("active");
    });
    $(document).on("ready", function() {
        if ($(window).width() > 991) {
            $("header").removeClass("active");
        }
        $(window).on("resize", function() {
            if ($(window).width() > 991) {
                $("header").removeClass("active");
            }
        });
    });
    </script>
    <!--//MENU-JS-->
    <script src="/assets/website/js/frontend/clashshare/bootstrap.min.js"></script>
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script><script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>